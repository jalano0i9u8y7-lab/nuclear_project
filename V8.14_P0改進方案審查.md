# V8.14 P0 改進方案審查

**日期**：2026-01-19  
**版本**：V8.14  
**狀態**：🔍 **審查中（待定案）**

---

## 📋 變更摘要

### 1. 模型名稱修正 ✅
- **GEMINI_FLASH**：`gemini-3.0-flash` → `gemini-3-flash-preview` ✅ 已修正
- **GEMINI_SEARCH**：`gemini-3-pro-preview` → `gemini-3-flash-preview` ✅ 已修正

### 2. P0/0.5/0.7 職權分工補充 ✅
- 已提供完整的職權分工表（不可混淆責權表）
- 明確三者的核心問題、本質角色、輸出型態、絕對禁止事項

### 3. P0 改進方案 🔍 **待審查**

---

## 🔍 P0 改進方案詳細審查

### **方案概述**

**目標**：解決 OPUS 模型內建知識時效性問題，透過 Gemini Flash 3.0 讀取最新 PDF 文件來補充驗證。

**流程設計**：
```
1. OPUS 第一次分析（原有 prompt + 新增「時效性防呆」要求）
   ↓
2. OPUS 提出「關鍵驗證問題」+ 資料來源（網址/網站/關鍵字）
   ↓
3. 人工下載 PDF → 放入 Google Drive
   ↓
4. Gemini Flash 3.0 讀取 PDF 並提取相關上下文（附頁數）
   ↓
5. 將 OPUS 第一次分析 + Gemini 提取的上下文 → 打包送回 OPUS
   ↓
6. OPUS 重新分析（標明問題已解決 + 資料來源）
   ↓
7. GPT 審查（原有流程）
```

---

## ✅ 優點分析

### 1. **解決時效性問題**
- ✅ 有效解決 OPUS 訓練數據截止日期的限制
- ✅ 可以獲取 2025-2026 最新動態（良率數據、供應商名單、法規細節等）

### 2. **設計合理**
- ✅ 保留 OPUS 第一次分析的完整文字（解決 API 失憶問題）
- ✅ 使用 Gemini Flash 3.0（成本低、2M 長窗口、適合讀取 PDF）
- ✅ 明確的資料來源要求（Tier 1 機構、近 12 個月、具體頁數）

### 3. **流程清晰**
- ✅ 階段分明：分析 → 提問 → 驗證 → 重新分析 → 審查
- ✅ 可追溯：每個問題都有資料來源和頁數引用

---

## ⚠️ 需要確認的問題

### **問題 1：OPUS Prompt 修改範圍**

**當前狀態**：
- `buildP0Prompt()` 函數有兩個版本：測試模式（簡化）和正式模式（完整）
- 正式模式的 prompt 非常長（約 350 行）

**建議**：
- ✅ 在 prompt **最後**加上「模型內建知識時效性防呆」段落
- ✅ 測試模式和正式模式都需要加上
- ⚠️ 需要確認是否只加在最後，還是也要整合到分析要求中？

### **問題 2：資料結構設計**

**需要新增的資料結構**：

#### **A. OPUS 第一次分析結果保存**
- **表格**：`P0__INITIAL_ANALYSIS` 或擴充 `P0__SNAPSHOT`
- **欄位**：
  - `job_id` / `snapshot_id`
  - `initial_analysis_json` - OPUS 第一次完整分析結果（JSON）
  - `validation_questions_json` - 關鍵驗證問題列表（JSON）
  - `created_at`

#### **B. 驗證問題追蹤**
- **表格**：`P0__VALIDATION_QUESTIONS`
- **欄位**：
  - `question_id`
  - `job_id` / `snapshot_id`
  - `question_text` - 問題內容
  - `data_source_url` - 資料來源網址
  - `data_source_site` - 資料來源網站
  - `data_source_keywords` - 關鍵字
  - `google_drive_folder_id` - Google Drive 資料夾 ID
  - `status` - PENDING / PDF_UPLOADED / PROCESSING / COMPLETED
  - `gemini_extracted_context_json` - Gemini 提取的上下文（JSON，包含頁數）
  - `created_at` / `updated_at`

#### **C. Gemini 文件處理記錄**
- **表格**：`P0__GEMINI_FILE_PROCESSING`
- **欄位**：
  - `file_id`
  - `question_id`
  - `google_drive_file_id` - Google Drive 檔案 ID
  - `gemini_file_uri` - Gemini File API 返回的 URI
  - `extracted_context_json` - 提取的上下文（JSON）
  - `processing_status` - UPLOADING / PROCESSING / COMPLETED / FAILED
  - `created_at` / `updated_at`

**問題**：
- ⚠️ 這些表格設計是否合理？
- ⚠️ 是否需要合併某些表格？
- ⚠️ 是否需要與現有的 `P0__SNAPSHOT` 整合？

### **問題 3：Gemini File API 實作細節**

**參考設計**：
```javascript
// 1. 從 Drive 獲取 Blob
var file = DriveApp.getFileById(driveFileId);
var blob = file.getBlob();

// 2. 上傳到 Gemini 暫存區 (POST upload/v1beta/files)
var uploadUrl = "https://generativelanguage.googleapis.com/upload/v1beta/files?key=" + API_KEY;
var metadata = { "file": { "display_name": file.getName() } };

// 3. 獲取 fileUri
// Response 包含: { "file": { "uri": "https://generativelanguage.googleapis.com/...", ... } }

// 4. 生成內容 (GenerateContent with File)
{
  "contents": [{
    "parts": [
      { "text": "這是 Opus 提出的驗證問題：[...問題列表...]。請根據這份文件回答，並引用頁數。" },
      { "file_data": { "mime_type": "application/pdf", "file_uri": FILE_URI } }
    ]
  }]
}
```

**需要確認**：
- ⚠️ GAS 的 `UrlFetchApp` 是否支持 `multipart/form-data` 格式上傳？
- ⚠️ Gemini File API 的認證方式（是否使用相同的 API Key）？
- ⚠️ 檔案生命週期管理（48 小時後自動刪除，是否需要手動刪除）？

### **問題 4：UI 對話視窗設計**

**附錄 1 描述**：
- P0 會產出：「請協助按照以下網址/網站/關鍵字下載標題為 xxxxxx 的 pdf 檔，並放入名稱/連結為 xxxx 的 googledrive 資料夾中，完成請回覆已完成」
- 使用者回復完成 → 觸發 Gemini Flash 工作
- 若有問題，也可回復給 OPUS 協助解決

**需要確認**：
- ⚠️ UI 對話視窗的實作方式（是否使用現有的 `M0__JOB_CONFIRMATION` 表格？）
- ⚠️ 如何觸發 Gemini Flash 工作（自動輪詢？手動觸發？）
- ⚠️ 如何處理「使用者回復給 OPUS」的場景（是否需要新的 M0 Job？）

### **問題 5：OPUS 重新分析的 Prompt 設計**

**需要設計**：
- 如何將 OPUS 第一次分析 + Gemini 提取的上下文打包？
- 如何設計 prompt 讓 OPUS 知道哪些問題已被解決？
- 如何要求 OPUS 標明資料來源和頁數？

**建議格式**：
```json
{
  "initial_analysis": { /* OPUS 第一次分析結果 */ },
  "validation_results": [
    {
      "question_id": "Q001",
      "question_text": "問題內容",
      "data_source": "資料來源",
      "extracted_context": [
        {
          "page_number": 15,
          "content": "提取的上下文",
          "relevance_score": 0.9
        }
      ],
      "answer_summary": "Gemini 提取的答案摘要"
    }
  ]
}
```

**問題**：
- ⚠️ 這個格式是否合理？
- ⚠️ OPUS 重新分析的 prompt 應該如何設計？

### **問題 6：錯誤處理**

**需要考慮的錯誤場景**：
1. **PDF 下載失敗**：使用者無法下載 PDF
2. **PDF 上傳失敗**：Google Drive 上傳失敗
3. **Gemini File API 上傳失敗**：上傳到 Gemini 失敗
4. **Gemini 提取失敗**：無法從 PDF 中提取相關上下文
5. **OPUS 重新分析失敗**：重新分析時出錯

**問題**：
- ⚠️ 每個錯誤場景應該如何處理？
- ⚠️ 是否需要重試機制？
- ⚠️ 是否需要降級方案（如果驗證失敗，是否仍使用第一次分析結果）？

---

## 💡 建議與優化

### **建議 1：分階段實施**

**階段一（MVP）**：
1. ✅ 修正模型名稱
2. ✅ 在 OPUS prompt 最後加上「時效性防呆」要求
3. ✅ 保存 OPUS 第一次分析結果和驗證問題
4. ✅ 實作 Gemini File API 讀取 PDF（手動觸發）

**階段二（完整流程）**：
1. ⏳ UI 對話視窗
2. ⏳ 自動觸發 Gemini Flash 工作
3. ⏳ OPUS 重新分析流程
4. ⏳ 完整的錯誤處理

### **建議 2：資料結構優化**

**建議合併表格**：
- `P0__VALIDATION_QUESTIONS` 和 `P0__GEMINI_FILE_PROCESSING` 可以合併為一個表格
- 或者擴充現有的 `P0__SNAPSHOT` 表格，新增相關欄位

### **建議 3：Prompt 設計優化**

**OPUS 重新分析的 Prompt 建議**：
```
你之前對以下產業進行了分析，並提出了 ${N} 個關鍵驗證問題。

現在，我們已經從你指定的資料來源中提取了相關上下文：

[列出每個問題的驗證結果，包含：
- 問題內容
- 資料來源（網址、網站、關鍵字）
- 提取的上下文（附頁數）
- 答案摘要]

請基於這些新的驗證結果，重新評估你的分析結論：

1. 標明哪些問題已被解決（附上資料來源和頁數）
2. 如果驗證結果與你之前的分析有衝突，請修正分析結論
3. 如果驗證結果支持你之前的分析，請加強論證
4. 如果某些問題仍無法驗證，請標明「無法驗證」並說明原因

最終判決：
基於你內建的深層邏輯，結合回覆的「合格證據」，完整評估該產業的潛力是否符合要求並給出最終分析結論。
```

---

## ✅ 確認事項（已確認）

### **技術確認** ✅
1. ✅ **GAS 的 `UrlFetchApp` 支援 `multipart/form-data`**：
   - 支援，但針對 Gemini API，建議用 `multipart/related` 並「手動組裝 Payload」
   - 原因：Google Gemini 的 Upload API 比較嚴格，需要精準控制 Metadata (JSON) 和 File (Binary) 的 Content-Type 順序
   - 最穩的寫法是手動組裝 Body

2. ✅ **Gemini File API 的認證方式**：
   - 使用相同的 API Key（與 Gemini 3.0 Flash/Pro 相同）
   - 傳遞方式：推薦放在 Header (`x-goog-api-key`)，比放在 URL (`?key=...`) 更安全且符合規範
   - 權限：該 Key 預設就包含了 `generative-language.googleapis.com` 的所有權限（包含 Chat 和 File Upload）

3. ✅ **檔案生命週期管理策略**：
   - **強烈建議「手動刪除 (Explicit Delete)」**
   - 雖然 Google 官方政策是 48 小時自動刪除，但依賴自動刪除有兩個壞處：
     - 配額佔用：Gemini File API 有總儲存空間限制（每專案 20GB）
     - 如果一次跑 100 份 PDF，累積起來可能會爆

### **設計確認** ✅
1. ✅ **資料結構設計**：
   - **擴充現有的 `P0__SNAPSHOT` 表格**，新增相關欄位
   - 不需要新建多個表格，統一在 `P0__SNAPSHOT` 中管理

2. ✅ **OPUS 重新分析的 Prompt 設計**：
   - 格式：第一次分析 A + 查證資料 B → 重新分析
   - 要求：註明新得到的資料對原來決策的影響是「支持」還是「中立」還是「修正」？
   - Prompt 範例：`這是你第一次按照(....原本的P0 prompt)做出的分析A與提出須查驗資料的問題，以下是幫你查到針對提問的資料文件上下文以及出處B，請重新按照你原本的分析A以及新得到的資料B重新分析出一個最精準的結論，並且註明新得到的資料對你原來決策的影響是支持還是中立還是修正?`

3. ✅ **錯誤處理策略**：
   - **PDF 下載失敗**：忽略提問，用原分析送入審查階段
   - 不需要降級方案，直接使用第一次分析結果

### **流程確認** ✅
1. ✅ **UI 對話視窗**：
   - 等後續再做，標記為「系統測試完成後的待處理工作」
   - 暫時不需要實作

2. ✅ **觸發 Gemini Flash 工作**：
   - 由人類完成下載後，在 UI 輸入觸發 Gemini Flash 工作
   - 手動觸發（不是自動輪詢）

3. ✅ **OPUS Prompt 修改**：
   - 刪除「至少十個問題」要求
   - 改為：「由於你內建知識時效或廣度不足而必須查核的關鍵問題」
   - 不限定數目，沒有也沒關係

---

## 📝 設計方案（待定案後實現）

### **1. 資料結構設計**

#### **擴充 `P0__SNAPSHOT` 表格**

**新增欄位**：
- `initial_analysis_json` - OPUS 第一次完整分析結果（JSON）
- `validation_questions_json` - 關鍵驗證問題列表（JSON）
- `validation_status` - PENDING / IN_PROGRESS / COMPLETED / SKIPPED
- `gemini_validation_results_json` - Gemini 提取的驗證結果（JSON）
- `final_analysis_json` - OPUS 重新分析結果（JSON，包含影響標註：支持/中立/修正）

**`validation_questions_json` 格式**：
```json
[
  {
    "question_id": "Q001",
    "question_text": "問題內容",
    "data_source_url": "資料來源網址",
    "data_source_site": "資料來源網站",
    "data_source_keywords": "關鍵字",
    "google_drive_folder_id": "Google Drive 資料夾 ID",
    "status": "PENDING / PDF_UPLOADED / PROCESSING / COMPLETED / SKIPPED"
  }
]
```

**`gemini_validation_results_json` 格式**：
```json
[
  {
    "question_id": "Q001",
    "google_drive_file_id": "Google Drive 檔案 ID",
    "gemini_file_uri": "Gemini File API URI",
    "extracted_context": [
      {
        "page_number": 15,
        "content": "提取的上下文",
        "relevance_score": 0.9
      }
    ],
    "answer_summary": "Gemini 提取的答案摘要",
    "data_source": "資料來源（網址、網站、關鍵字）"
  }
]
```

**`final_analysis_json` 格式**：
```json
{
  "revised_analysis": { /* OPUS 重新分析結果 */ },
  "validation_impact": [
    {
      "question_id": "Q001",
      "impact_type": "SUPPORT / NEUTRAL / CORRECTION",
      "impact_description": "影響說明",
      "data_source": "資料來源",
      "page_references": [15, 23, 45]
    }
  ]
}
```

### **2. OPUS Prompt 修改**

#### **在 `buildP0Prompt()` 最後加上「時效性防呆」段落**

**新增內容**（測試模式和正式模式都需要加上）：
```
---

## ⭐ 模型內建知識時效性防呆

請分析你篩選出的潛力產業。針對每一個產業，誠實地列出你「因為訓練數據截止而無法確定的 2025-2026 最新動態」（例如：具體的良率數據、最新通過驗證的供應商名單、剛發布的法規細節）。

並針對上述盲點，提出「由於你內建知識時效或廣度不足而必須查核的關鍵問題」。

**要求**：
- 這些問題必須是能透過查詢「學術論文」、「頂級投行研報 (IB Reports)」或「產業智庫白皮書」來回答的硬數據
- 你必須主動提供每個問題的硬數據報告應該要去哪裡下載或搜尋（給網址、網站、或是關鍵字與準確白名單）
- 資料來源必須能夠準確下載到能解決你的提問的文件檔案
- Gemini 會按照你提供的資料來源分析文件內容，並擷取相關的上下文給你看，讓你自己解決自己的提問

**審查標準**：
- **來源權威性**：資料是否來自 Tier 1 機構（如 Goldman, McKinsey, IEEE, Nature, 政府單位）？野雞報告一律不採信
- **時效性**：資料是否為近 12 個月內發布？過時資料不採信
- **引用精確度**：回答中是否提供了具體的頁數 (Page Number) 與原文引述？若含糊其辭，視為幻覺

**最終判決**：
基於你內建的深層邏輯，結合回覆的「合格證據」，完整評估該產業的潛力是否符合要求並給出最終分析結論。若證據顯示市場過熱或技術卡關，請果斷否決。

**輸出格式**（在原有 JSON 格式中新增）：
{
  "themes": [
    {
      // ... 原有欄位 ...
      "validation_questions": [
        {
          "question_id": "Q001",
          "question_text": "問題內容",
          "data_source_url": "資料來源網址",
          "data_source_site": "資料來源網站",
          "data_source_keywords": "關鍵字",
          "expected_document_title": "預期文件標題"
        }
      ]
    }
  ]
}
```

### **3. OPUS 重新分析的 Prompt 設計**

**函數**：`buildP0ReanalysisPrompt(initialAnalysis, validationResults)`

**Prompt 內容**：
```
你之前對以下產業進行了分析，並提出了 ${N} 個關鍵驗證問題。

**你的第一次分析（分析 A）**：
${JSON.stringify(initialAnalysis, null, 2)}

**查證結果（資料 B）**：
以下是我們從你指定的資料來源中提取的相關上下文：

${validationResults.map(result => `
**問題 ${result.question_id}**：${result.question_text}
- **資料來源**：${result.data_source}
- **提取的上下文**：
${result.extracted_context.map(ctx => `  - 第 ${ctx.page_number} 頁：${ctx.content}`).join('\n')}
- **答案摘要**：${result.answer_summary}
`).join('\n\n')}

**請重新分析**：

請重新按照你原本的分析 A 以及新得到的資料 B，重新分析出一個最精準的結論。

**要求**：
1. 標明哪些問題已被解決（附上資料來源和頁數）
2. 如果驗證結果與你之前的分析有衝突，請修正分析結論
3. 如果驗證結果支持你之前的分析，請加強論證
4. 如果某些問題仍無法驗證，請標明「無法驗證」並說明原因
5. **必須註明新得到的資料對你原來決策的影響是「支持」、「中立」還是「修正」？**

**輸出格式**：
{
  "revised_analysis": {
    // 重新分析後的完整結果（格式同第一次分析）
  },
  "validation_impact": [
    {
      "question_id": "Q001",
      "impact_type": "SUPPORT / NEUTRAL / CORRECTION",
      "impact_description": "影響說明（例如：驗證結果支持原分析，良率數據符合預期）",
      "data_source": "資料來源",
      "page_references": [15, 23, 45]
    }
  ],
  "final_judgment": "最終判決：基於你內建的深層邏輯，結合回覆的「合格證據」，完整評估該產業的潛力是否符合要求並給出最終分析結論。"
}
```

### **4. Gemini File API 實作**

#### **函數：`uploadFileToGemini(driveFileId)`**

**實作要點**：
1. 使用 `multipart/related` 手動組裝 Payload
2. API Key 放在 Header (`x-goog-api-key`)
3. 上傳後返回 `file_uri`
4. 處理完成後手動刪除檔案

**參考實作**：
```javascript
function uploadFileToGemini(driveFileId) {
  const apiKey = getAPIKey("GOOGLE");
  const file = DriveApp.getFileById(driveFileId);
  const blob = file.getBlob();
  const fileName = file.getName();
  
  // 手動組裝 multipart/related Payload
  const boundary = "----WebKitFormBoundary" + Utilities.getUuid();
  const metadata = JSON.stringify({ file: { display_name: fileName } });
  
  // 組裝 multipart/related body
  let body = "";
  body += `--${boundary}\r\n`;
  body += `Content-Type: application/json\r\n\r\n`;
  body += `${metadata}\r\n`;
  body += `--${boundary}\r\n`;
  body += `Content-Type: application/pdf\r\n\r\n`;
  body += Utilities.newBlob(blob.getBytes()).getDataAsString();
  body += `\r\n--${boundary}--\r\n`;
  
  // 上傳到 Gemini
  const uploadUrl = "https://generativelanguage.googleapis.com/upload/v1beta/files";
  const response = UrlFetchApp.fetch(uploadUrl, {
    method: "POST",
    headers: {
      "x-goog-api-key": apiKey,
      "Content-Type": `multipart/related; boundary=${boundary}`
    },
    payload: body,
    muteHttpExceptions: true
  });
  
  if (response.getResponseCode() !== 200) {
    throw new Error(`Gemini File API 上傳失敗：${response.getContentText()}`);
  }
  
  const result = JSON.parse(response.getContentText());
  return result.file.uri;
}
```

#### **函數：`extractContextFromGeminiFile(fileUri, questions)`**

**實作要點**：
1. 使用 Gemini Flash 3.0 讀取 PDF
2. 針對每個問題提取相關上下文
3. 要求附上頁數

**參考實作**：
```javascript
function extractContextFromGeminiFile(fileUri, questions) {
  const apiKey = getAPIKey("GOOGLE");
  const model = "gemini-3-flash-preview";
  
  const prompt = `這是 Opus 提出的驗證問題：
${questions.map((q, i) => `${i + 1}. ${q.question_text}`).join('\n')}

請根據這份文件回答每個問題，並：
1. 引用具體的頁數 (Page Number)
2. 提供原文引述
3. 針對每個問題提供答案摘要

輸出格式（JSON）：
{
  "answers": [
    {
      "question_id": "Q001",
      "question_text": "問題內容",
      "extracted_context": [
        {
          "page_number": 15,
          "content": "提取的上下文",
          "relevance_score": 0.9
        }
      ],
      "answer_summary": "答案摘要"
    }
  ]
}`;
  
  const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
  
  const requestBody = {
    contents: [{
      parts: [
        { text: prompt },
        { file_data: { mime_type: "application/pdf", file_uri: fileUri } }
      ]
    }]
  };
  
  const response = UrlFetchApp.fetch(apiUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    payload: JSON.stringify(requestBody),
    muteHttpExceptions: true
  });
  
  if (response.getResponseCode() !== 200) {
    throw new Error(`Gemini 提取失敗：${response.getContentText()}`);
  }
  
  const result = JSON.parse(response.getContentText());
  return JSON.parse(result.candidates[0].content.parts[0].text);
}
```

#### **函數：`deleteGeminiFile(fileUri)`**

**實作要點**：
1. 處理完成後手動刪除檔案
2. 釋放配額

**參考實作**：
```javascript
function deleteGeminiFile(fileUri) {
  const apiKey = getAPIKey("GOOGLE");
  const fileId = fileUri.split('/').pop();  // 從 URI 提取 file ID
  
  const deleteUrl = `https://generativelanguage.googleapis.com/v1beta/files/${fileId}?key=${apiKey}`;
  
  const response = UrlFetchApp.fetch(deleteUrl, {
    method: "DELETE",
    muteHttpExceptions: true
  });
  
  if (response.getResponseCode() !== 200) {
    Logger.log(`⚠️ Gemini 檔案刪除失敗：${response.getContentText()}`);
  }
}
```

### **5. 流程整合**

#### **修改 `P0_ProcessM0Result()`**

**新增邏輯**：
1. 保存 OPUS 第一次分析結果到 `P0__SNAPSHOT.initial_analysis_json`
2. 提取驗證問題到 `P0__SNAPSHOT.validation_questions_json`
3. 如果沒有驗證問題，直接進入 GPT 審查階段
4. 如果有驗證問題，等待人工下載 PDF 並觸發 Gemini Flash 工作

#### **新增函數：`P0_ProcessValidationResults(jobId, geminiResults)`**

**功能**：
1. 更新 `P0__SNAPSHOT.gemini_validation_results_json`
2. 打包第一次分析 + 驗證結果 → 送回 OPUS 重新分析
3. 保存重新分析結果到 `P0__SNAPSHOT.final_analysis_json`
4. 進入 GPT 審查階段（使用重新分析結果）

#### **新增函數：`P0_TriggerGeminiValidation(jobId, googleDriveFolderId)`**

**功能**：
1. 讀取 `P0__SNAPSHOT.validation_questions_json`
2. 掃描 Google Drive 資料夾中的 PDF
3. 對每個 PDF：
   - 上傳到 Gemini
   - 提取相關上下文
   - 記錄結果
   - 刪除 Gemini 檔案
4. 觸發 `P0_ProcessValidationResults()`

---

## 📝 下一步行動

1. ✅ **已完成**：修正模型名稱
2. ✅ **已完成**：補充 P0/0.5/0.7 職權分工
3. ✅ **已完成**：技術確認和設計確認
4. ✅ **已完成**：設計具體實現方案（本文檔）
5. ⏳ **待定案**：等待用戶說「定案」後開始實現和更新 SSOT 文檔

---

## 🎯 設計用意說明

**用戶說明**：
> 因為我們系統是單線式設計，所以源頭如果不精準或有錯誤，後面每個階段都會幾何指數放大。所以才又做了一個防呆的機制。

**理解**：
- P0 是整個系統的源頭，如果 P0 分析不準確，後續 P1、P2、P3 都會受到影響
- 透過時效性防呆機制，確保 P0 的分析基於最新、最準確的資料
- 這是一個「品質控制」機制，而非「功能增強」

---

**此文檔已完成審查和設計方案，等待用戶說「定案」後才開始實現和更新 SSOT 文檔。**
